// v1.2

/**
 * Adds docker support for the repository.
 *
 * To use this script:
 * 1) Add task "prepareFilesForDocker" for each subproject that will prepare files (at "src/main/docker") that have to be included into the docker image
 * 2) Add "dockerImageName" ext property with desired image name to each subproject
 * 3) Place Dockerfile to "src/main/docker/Dockerfile" for each subproject
 * 4) Define "docker.dockerCommonPath" property for root project
 *
 * Execution: gradlew dockerPublishImage
 *
 * Created tasks:
 * :dockerLogin
 * :dockerLogout
 * :SUBPROJECT:dockerRemoveExistingImage
 * :SUBPROJECT:copyDockerfile
 * :SUBPROJECT:dockerBuildImage
 * :SUBPROJECT:dockerPublishImage
 */

import org.apache.tools.ant.filters.ReplaceTokens

def DOCKER_REGISTRY_USERNAME = System.getenv('DOCKER_USER') ?: "FakeArtifactoryUser"
def DOCKER_REGISTRY_PASSWORD = System.getenv('DOCKER_PASS') ?: "FakeArtifactoryPass"
def DOCKER_REGISTRY_URL = System.getenv('DOCKER_REPOSITORY') ?: 'fake.epam.com:0'

def dockerCommonPath = rootProject.properties['docker.dockerCommonPath']
def dockerFullCommonPath = DOCKER_REGISTRY_URL + dockerCommonPath

ext.dockerFullCommonPath = dockerFullCommonPath

def debugDockerBuild = Boolean.parseBoolean(project.findProperty("debugDockerBuild") ?: 'false')

task dockerLogin(type: Exec) {
    commandLine "docker", "login", "--username=$DOCKER_REGISTRY_USERNAME", "--password=$DOCKER_REGISTRY_PASSWORD", "$DOCKER_REGISTRY_URL"

    if (debugDockerBuild) {
        doFirst {
            println "Exec: " + commandLine.toString().replace(DOCKER_REGISTRY_PASSWORD, "HIDDEN_PASSWORD")
        }
    }
}

task dockerLogout(type: Exec) {
    commandLine "docker", "logout", "$DOCKER_REGISTRY_URL"

    if (debugDockerBuild) {
        doFirst {
            println "Exec: " + commandLine
        }
    }
}

// Always do a logout if login was executed
dockerLogin.finalizedBy dockerLogout

// Example: 5.3.21
def dockerFullTagVersion = rootProject.properties['version'].toString()
ext.dockerFullTagVersion = dockerFullTagVersion

// Example: 5.3
def dockerShortTagVersion = dockerFullTagVersion.substring(0, version.lastIndexOf('.'))


task printDockerTagVersion {
    doLast {
        println "Docker full tag version: " + dockerFullTagVersion
        println "Docker short tag version: " + dockerShortTagVersion
    }
}
dockerLogin.dependsOn printDockerTagVersion

allprojects {

    // We have to do that only after all evaluation is finished because otherwise we will not see other tasks
    afterEvaluate {

        def prepareFilesForDockerTask = tasks.findByName('prepareFilesForDocker')
        //println "Tasks: " + project.tasks
        //println "Task: " + prepareFilesForDockerTask
        if (prepareFilesForDockerTask) {
            // This project has Docker task

            def dockerImageName = project.ext['dockerImageName']
            def imageUrl = dockerFullCommonPath + dockerImageName
            def urlWithFullVersion = imageUrl + ":" + dockerFullTagVersion
            def urlWithShortVersion = imageUrl + ":" + dockerShortTagVersion
            def urlWithLatestTag = imageUrl + ":latest"
            def dockerFileSrc = project.file('src/main/docker/Dockerfile')
            def dockerDestDir = project.file("$buildDir/docker/")
            project.ext.dockerUrlWithLatestTag = urlWithLatestTag

            if (debugDockerBuild) {
                println dockerImageName
                println urlWithFullVersion
                println urlWithShortVersion
                println urlWithLatestTag
                println dockerFileSrc.path
                println dockerDestDir.path
            }

            def cleanTask = tasks.findByName('clean')
            prepareFilesForDockerTask.mustRunAfter(cleanTask)
            // Configure original task to be executed after clean if clean requested

            // dockerRemoveExistingImage
            def dockerRemoveExistingImageTask = tasks.create('dockerRemoveExistingImage', Exec) {
                group 'docker'
                dependsOn dockerLogin
                description 'Removes existing docker image tags if it\'s has same tags as image we going to create'

                workingDir rootDir
                ignoreExitValue true

                // You can change list of tags/branches to be deleted
                // TODO: Make this a configuration option
                commandLine "docker", "rmi", urlWithShortVersion, urlWithFullVersion

                if (debugDockerBuild) {
                    doFirst {
                        println "Exec: " + commandLine
                    }
                }
            }
            dockerLogout.mustRunAfter dockerRemoveExistingImageTask

            def dockerFileReplaceTokens = project.ext.has('dockerFileReplaceTokens') ? project.ext['dockerFileReplaceTokens'] : null

            // copyDockerfile
            def copyDockerfileTask = tasks.create('copyDockerfile', Copy) {
                group 'docker'
                from dockerFileSrc
                into dockerDestDir
                mustRunAfter cleanTask

                if (dockerFileReplaceTokens != null) {
                    filter(ReplaceTokens, tokens: dockerFileReplaceTokens)
                }

                if (debugDockerBuild) {
                    doLast {
                        println "From: " + dockerFileSrc.path
                        println "Into: " + dockerDestDir.path
                        println "dockerFileReplaceTokens: " + dockerFileReplaceTokens
                    }
                }
            }

            // dockerBuildImage
            def dockerBuildImageTask = tasks.create('dockerBuildImage', Exec) {
                group 'docker'
                description 'Build docker image and applied two tags on it: tag vith current version and "latest" tag'

                dependsOn prepareFilesForDockerTask
                dependsOn copyDockerfileTask
                dependsOn dockerLogin
                dependsOn dockerRemoveExistingImageTask


                workingDir dockerDestDir
                // You can change list of tags/branches to be created
                // TODO: Make this a configuration option
                commandLine "docker", "build", "-t", urlWithShortVersion, "-t", urlWithFullVersion, "-f", "./Dockerfile", "--rm", "."

                if (debugDockerBuild) {
                    doFirst {
                        println "Exec: " + commandLine
                    }
                }
            }
            dockerLogout.mustRunAfter dockerBuildImageTask

//            // dockerPublishImage
//            def dockerPublishImageTask = tasks.create('dockerPublishImage', Exec) {
//                group 'docker'
//                description 'Upload docker image to the repository'
//
//                dependsOn dockerBuildImageTask
//
//                workingDir rootDir
//                commandLine "docker", "push", imageUrl
//
//                if (debugDockerBuild) {
//                    doFirst {
//                        println "Exec: " + commandLine
//                    }
//                }
//            }
//            dockerLogout.mustRunAfter dockerPublishImageTask

        }
    }
}
